# 4. 클래스, 객체, 인터페이스

## 인터페이스

- No 상태(No backing field)
  - 프로퍼티는 선언 가능
- override 변경자 필수!
- default 키워드 No 필요
- 여러 인터페이스를 구현하느라 본문이 있는 메소드의 시그니처가 중복된다면? override 필수!
- 상위 타입? super<ParentClass>
- 자바에서는 코틀린의 디폴트 메소드 구현에 의존할 수 없다.
  - 자바 6에 호환되므로 디폴트 메소드가 없어서 스태틱 메소드에 구현부가 들어간다.

## 상속 제어

- 코틀린의 클래스는 기본적으로 final!
- open 키워드로 상속 허용
- override 메소드는 기본적으로 open, 막으려면 final override
- abstract 클래스의 추상 멤버는 항상 open
- 인터페이스 멤버는 무조건 open, 막을 수 없다.

## 가시성 제어

- 코틀린은 기본적으로 public
- package-private은 없다.
- internal은 모듈 내부 공개
  - 모듈은 한꺼번에 컴파일되는 코틀린 파일들
  - 바이트코드 상에서는 public이 된다.
- 최상위 선언에 대해서 private 허용 - 클래스, 함수, 프로퍼티
  - 선언된 파일 내부에서만 사용할 수 있다.
- 코틀린의 protected는 같은 패키지 No no
- 중첩 클래스는 기본적으로 No 내부 클래스
  - 자바의 static 중첩 클래스와 같다.
  - 바깥 클래스를 참조하게 하려면 inner class
  - 바깥 클래스는 this@Outer

### Sealed Class

- 봉인된 클래스는 클래스 외부에 자신을 상속한 클래스를 둘 수 없다!
- when 식의 디폴트 분기를 피하는 방법
- 같은 파일 안에서! 하위 클래스를 만들 수 있다. since 1.1
- 데이터 클래스로 하위 클래스를 만들 수 있다. since 1.1
- [ ] No봉인 when을 봉인하는 과제!

## 생성자

- constructor 키워드는 생성자
- init 키워드는 초기화 블록
- 프로퍼티를 초기화하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있다.
- 모든 생성자 파라미터에 디폴트 값을 주면 파라미터가 없는 생성자가 자동으로 만들어진다!
- 클래스를 상속할 땐 기반 클래스의 생성자를 꼭 호출해야 한다.
  - 클래스 상속 목록에서 이름 뒤에 괄호가 있으면 클래스, 없으면 인터페이스
- private constructor로 외부 인스턴스화를 막을 수 있다.
  - companion object(동반 객체) 안에서 비공개 생성자를 사용하면 좋다.
  - 유틸리티나 싱글턴을 만들 때에는 private constructor 말고 최상위 함수, 싱글턴 객체를 선언하자!
- 주 생성자 없이 부 생성자만 선언할 수 있다.
  - 주 생성자가 없으면 모든 부 생성자는 반드시 상위 클래스를 초기화 해야 한다.

## 인터페이스에 선언된 프로퍼티 구현

- 추상 프로퍼티나 커스텀 게터가 있는 프로퍼티를 선언할 수 있다.
  - backing field는 안됨.
  - 자바 인터페이스에서 값 없이 게터, 세터 선언해놓는 것과 비슷하다.
- [ ] 인터페이스 추상 프로퍼티 구현을 여러 방식으로 해보는 과제!
- backing field를 만드는 방법은? 게터, 세터 구현부에서 field를 사용하면 된다.
- 접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 변경 가능~

## 데이터 클래스

- data class ClassName { }
- toString(), equals(), hashCode(), 그리고 copy()를 자동으로 생성해준다.

## 클래스 위임

- by 키워드로 데코레이터 패턴을 사용할 수 있다.

- 특정 메소드를 변경하려면 override

  class DelegateClass(val delegate: Child = Child()) : Parent by delegate { }

- [ ] final class를 위임해보는 과제!

## 싱글턴 클래스

- object ObjectName { }
- Comparator 구현 시 클래스 내부에 object를 선언해서 사용하면 좋다.
  - 다른 덴 안쓰는 게 낫다.
- 자바에서는 INSTANCE 필드로 접근하면 된다.

## 동반 객체(companion object)

- 최상위 함수는 비공개 멤버를 호출할 수 없다. 그럴 때 동반 객체를 사용하면 된다!
- 컴파일하면 정적 필드가 된다.
- private 생성자를 호출하기 딱 좋은 위치!
  - 팩토리 패턴에 사용하면 된다.
    - 자바의 static 팩토리 메소드처럼
    - open class에는 쓰지말기로 해요~
- 기본적으로 동반 객체 이름은 Companion이지만 이름을 붙여줘도 된다.
- 동반 객체에서 인터페이스를 구현하면, 그 클래스를 해당 인터페이스 타입으로 사용할 수 있다.
- 클래스에 동반 객체를 선언해두면, 클래스 밖에서 동반 객체에 확장 함수를 작성할 수 있다.
- [ ] 동반 객체로 팩토리 패턴을 구현해보는 과제!

## 객체 식(object expression)

- 자바의 무명 클래스

- final이 아닌 변수도 사용할 수 있다!

- 함수형 인터페이스를 구현할 때는 요거 말고 SAM 변환을 사용해라.

  `someExecutor.execute(`
  	`object : Executable() {`
  		`override fun excute() { ... }`
  		`override fun stop() { ... }`
  `)`

# 5. 람다

- 파라미터 목록에 괄호를 쓰지 않는다!
- this는 람다식 말고 바깥의 클래스(자바와 동일)
- 람다를 바로 실행할 땐 run을 사용
- 함수 맨뒤 파라미터가 람다 식이라면 괄호 밖으로 람다를 뺄 수 있다.
- 함수의 유일한 인자가 람다 식이라면 괄호를 아예 생략!
- 람다의 파라미터가 하나면 it을 쓰자!
  - 람다를 변수에 저장할 때는 타입 추론이 불가능해서 it 못씀!!!
- 멤버 참조(::)로 최상위 함수나 최상위 프로퍼티도 참조할 수 있다.
  - 앞에 클래스 없이 바로 ::
- 생성자 참조는 ::ClassName

### scope 안의 변수에 접근하기

- 함수 안의 람다는 그 함수의 변수를 capture해서 다 사용할 수 있다. final 변수가 아닌 변수도!
  - 클로저! - 람다에서 시작하는 모든 참조가 포함된 닫힌 객체 그래프
    - 파이널 변수 - 람다 코드랑 같이 저장
    - 파이널 아닌 변수 - 래퍼(Ref class)로 감싸서 get, set 가능하게 한 다음 람다 코드랑 같이 저장
- 이벤트 핸들러 같은 비동기 처리에는 조심해서 사용!
  - 람다가 capture한 변수를 변경하는 시점이 함수가 이미 값을 리턴한 이후일 수 있다.
- [ ] 변수 사용하는 for문 람다로 변경하기 과제!

## Collection 함수형 API

- Stream 변환 없이도 filter, map 등등을 사용할 수 있다!
  - 하지만 효율이 떨어진다는 점!!!!
- !any == all, !all == any
  - 조건의 부정 대신 반대인 함수를 사용하자.
- find == firstOrNull
- flatMap { it } == flatten
- 지연 연산을 하려면 asSequence()를 사용하자!
  - 자바 Stream과 거의 같다.
  - Sequence에는 자바 Stream의 병렬처리가 없다.
  - generateSequence() 로 직접 시퀀스 생성 가능

## SAM(Single Abstract Method 단일 추상 메소드)

- 자바 functional interface
- 포획 변수가 없으면 매 호출마다 같은 인스턴스를 사용한다. 한번만 생성~
- 코틀린 함수에서는 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환하지 않는다.
  - 자바 함수에 대해서는 알아서 해줌

### SAM 생성자

- 함수형 인터페이스의 인스턴스를 반환하려면 ClassName { it.something } 처럼 SAM 생성자로 감싸야 한다.

### with 함수

- 수신 객체, 람다식을 받는 함수
- 람다 안에서 this는 수신 객체를 가리킨다. 혹은 생략도 가능~

### apply 함수

- SomeClass.apply { }
- 확장함수이다.
- with 함수와 똑같은데 마지막에 자기 자신을 반환한다.
- [ ] with, apply 활용해서 리팩토링하는 과제!
