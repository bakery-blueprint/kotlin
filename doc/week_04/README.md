# 8장 고차 함수 : 파라미터와 반환 값으로 람다 사용

고차함수로 코드를 더 간결하게, 코드 중복 없애기, 더 나은 추상화 구축





## 8.1 고차 함수 정의

고차함수 : 다른 함수를 인자로 받거나 함수를 반환하는 함수

코틀린은 람다나 함수 참조를 사용해 함수를 값으로 표현 가능



filter, map, with ...



### 8.1.1 함수 타입 

람다 인자의 타입을 어떻게 선언해야 할까?



코틀린의 타입 추론으로 인해 변수 타입을 따로 지정하지 않아도 람다를 변수에 대입할 수 있음.

````````````kotlin
(파라미터 타입) -> 반환 타입
(Int, String) -> Unit
````````````

일반적으로 함수 정의할 때 Unit의 경우 생략해도 되지만, 함수 타입을 선언할 때는 반환 타입을 반드시 명시해야 하므로 Unit 생략 불가



* 반환 타입을 널이 될 수 있는 타입으로 지정할 수 있음 `?`
* 함수 타입 변수 자체를 널이 될 수 있는 타입으로 정의할 수 있음

### 8.1.2 인자로 받은 함수 호출



### 8.1.3 자바에서 코틀린 함수 타입 사용

컴파일된 코드 안에서 함수 타입은 일반 인터페이스로 바뀐다.

함수 타입의 변수는 FunctionN 인터페이스를 구현하는 객체를 저장 (함수 인자의 개수에 따라 FunctionN<Parameter n개, Return>)

자바 8 이전은 필요한 FunctionN 인터페이스의 invoke 메소드를 구현하는 무명 클래스를 넘기면됨.



### 8.1.4 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터

파라미터를 함수 타입으로 선언할 때 디폴트 값을 정할 수 있음

디폴트 파라미터를 선언한 경우

1. 람다를 생략 : 디폴트 람다로
2. 인자 목록 뒤에 람다 전달
3. 이름 붙은 인자로 람다 전달 

또는 null이 될 수 있는 함수 타입으로도 가능

```kotlin
transform?.invoke(element)?:element.toString()
```



### 8.1.5 함수를 함수에서 반환

함수의 반환 타입으로 함수 타입을 지정해야함



### 8.1.6 람다를 활용한 중복 제거





## 8 .2 인라인 함수 : 람다의 부가 비용 없애기

람다가 변수를 포획하면, 람다 생성 시점마다 새로운 무명 클래스 객체 생성 -> 생성에 따른 부가비용 발생

`inline` 변경자 : 컴파일러가 해당 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기



### 8.2.1 인라이닝이 작동하는 방식

함수의 본문이 inline된다? -> 함수를 호출하는 코드를 `함수 본문을 번역한 바이트코드로 컴파일` 

함수에 전달된 람다의 본문도 함께 인라이닝됨. (람다를 함수 인터페이스를 구현하는 무명 클래스로 감싸지 않음)



```kotlin
class LockOwner(val lock: Lock) {
  fun runUnderLock(body: () -> Unit) {
    synchronized(lock, body)
  }
}
```

위 처럼 람다 대신 함수 타입인 변수를 인자로 넘기는 경우, 인라인 함수를 호출하는 코드 위치에서는 변수에 저장된 람다의 코드를 알 수 없음. 따라서 람다 본문은 인라이닝 되지 않고, 함수의 본문만 인라이닝됨



### 8.2.2 인라인 함수의 한계

* 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 람다를 표현하는 객체가 어딘가는 존재해야 하기 때문에 람다를 인라이닝할 수 없음

* 인라인 함수의 본문에서 람다 식을 바로 호출하거나, 람다 식을 인자로 전달받아 바로 호출하는 경우가 아니라면 `Illegal usage of inline-parameter` 인라이닝 금지

* 둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝하고 싶을 때

  파라미터 이름 앞에 `noinline` 변경자를 붙여줌으로써 인라이닝 금지

### 8.2.3 컬렉션 연산 인라이닝

코틀린이 제공하는 함수 인라이닝을 믿고 성능에 신경 쓰지 않아도 됨 (람다 본문이 호출한 위치에 함께 들어가기 때문에, 직접 만들어 쓰는 것이나 제공되는 것이나 성능에 차이가 없음)



처리할 원소가 많아지면 중간 리스트를 사용하는 부가 비용도 증가 -> asSequence를 통해 중간 리스트 부가 비용 줄이기

위의 경우 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현. 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출 (시퀀스는 람다를 저장해야 하므로 인라인하지 않음)

따라서 지연 계산을 통한 성능 향상을 목적으로 모든 컬렉션에 asSequence를 붙이는 것은 X

시퀀스를 통해 성능을 향상시킬 수 있는 경우는 __컬렉션 크기가 큰 경우__ 뿐이다



### 8.2.4 함수를 인라인으로 선언해야 하는 경우

일반 함수 호출의 경우 JVM은 이미 강력하게 인라이닝을 지원 (inline 키워드를 사용해도 람다를 인자로 받는 함수만 성능이 좋아질 가능성이 높음)

__람다를 인자로 받는 함수를 인라이닝하는 것의 이점__

1. 인라이닝을 통해 상당한 부가 비용은 없앨 수 있다
2. 현재의 JVM이 함수 호출과 람다를 인라이닝해 줄 정도로 똑똑하지 못하다
3. 인라이닝을 사용하면 일반 람다에서 사용할 수 없는 몇 가지 기능을 사용할 수 있음 (ex. non-local)



inline 변경자를 붙일 때 주의 해야할 점은, 함수가 큰 경우 바이트코드가 전체적으로 아주 커질 수 있음 -> 람다 인자와 무관한 코드를 별도의 비인라인 함수로 빼낼 수 있음



### 8.2.5 자원 관리를 위해 인라인된 람다 사용

람다로 중복을 없애는 일반적인 대표 패턴 : 자원 관리 패턴

withLock (java의 synchronized), use (java의 try-with-resource)





## 8.3 고차 함수 안에서 흐름 제어

람다 안에서 return 



### 8.3.1 람다 안의 return문: 람다를 둘러싼 함수로부터 반환

람다 안에서 return을 사용하면 람다로부터만 반환되는게 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환됨 -> 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 return문을 `non-local return`

인라이닝되지 않는 함수에 전달되는 람다 안에서 return을 사용할 수 없음



### 8.3.2 람다로부터 반환 : 레이블을 사용한 return

local return은 람다의 실행을 끝내고, 람다를 호출했던 코드의 실행을 계속 이어감 `local@`

```kotlin
fun lookForAlice(people: List<Person) {
  people.forEach label@ {
    if (it.name == "Alice") return@label
  }
  println("Alice might be somewhere")	// 무조건 출력됨
}
```



혹은 인라인함수의 이름을 레이블로 사용해도됨 (ex. return@forEach)



### 8.3.3 무명 함수 : 기본적으로 로컬 return

람다 식 대신 무명함수를 사용하며, return은 가장 가까운 함수인 무명함수를 return함

fun을 찾아 return 한다!!



# 9장 제네릭스



## 9.1 제네릭 타입 파라미터

기본적인 개념은 자바와 비슷

코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있음 (빈 리스트를 만들어야 한다면 타입 인자를 추론할 근거가 없기 때문에 직접 타입 인자를 명시해야 함)



### 9.1.1 제네릭 함수와 프로퍼티

* 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야함

* 확장 함수에서는 수신 객체나 파라미터 타입에 타입 파라미터를 사용할 수 있음

* 제네릭 확장 프로퍼티도 선언할 수 있음 (일반 프로퍼티는 타입 파라미터 가질 수 없음)



### 9.1.2 제네릭 클래스 선언

자바와 마찬가지로 타입 파라미터를 넣은 꺾쇠 기호 `<>` 를 클래스or인터페이스 이름뒤에 붙이면 제네릭하게 만들 수 있음

```kotlin
class StringList: List<String> {
  override fun get(index: Int): String = ...	// 구체적인 타입인자로 String을 지정
}
class ArrayList<T> : List<T> {
  override fun get(index: Int): T = ...	//타입 파라미터 T를 타입인자로 넘김
}
```



### 9.1.3 타입 파라미터 제약

클래스나 함수에 사용할 수 있는 (상한) 타입 인자를 제한하는 기능

```kotlin
fun <T : Number> List<T>.sum() : T
```

* 타입 파라미터 T에 대한 상한을 정하고 나면 T 타입의 값을 그 상한 타입의 값으로 취급할 수 있음

  (ex. 상한 타입에 정의된 메소드 호출 가능)



### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정

* 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 것과 동일
* 널이 될 수 없는 타입만 타입 인자로 받게 만들려면 타입 파라미터에 제약을 줘야함 (Any를 상한으로)



## 9.2 실행 시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터

JVM의 제네릭스는 보통 타입 소거를 사용해 구현됨 

-> 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있디 않다는 뜻



### 9.2.1 실행 시점의 제네릭: 타임 검사와 캐스트

코틀린 제네릭 타입 인자 정보는 런타임에 지워진다 (자바와 동일) -> List<String>을 만들어도 실행 시점에서는 List로 봄



* val list1: List<String> = listOf("a", "b")
* val list2: List<Int> = listOf(1, 2, 3)

컴파일러는 위의 두 리스트를 서로 다른 타입으로 인식. but 실행 시점에 둘은 같은 타입의 객체로 인식

때문에 is 검사로 타입 인자로 지정한 타입을 검사할 수 없음 (List는 검사할 수 있으나, List<String>인지 List<Int>인지는 모름)

```kotlin
>>> if (value is List<String>) { ... }
ERROR: Cannot check for instance of erased type
```

__스타 프로젝션__을 사용하여 검사

```kotlin
if (value is List<*>) { ... }
```



다만 저장해야 하는 타입 정보의 크기가 줄어들어서 전반적인 메모리 사용량이 줄어든다는 타입 소거의 장점!





### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언

 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워짐 -> 제네릭 클래스의 인스턴스가 있어도 그 인스턴스를 만들 때 사용한 타입 인자를 알 수 없음



__인라인 함수__의 타입 파라미터는 실체화되므로 실행 시점에 타입 인자를 알 수 있음! (어떤 함수에 inline 키워드를 붙이면 컴파일러가 호출 부분을 함수 본문으로 대치! 8.2절 참고)

```kotlin
inline fun <reified T> isA(value: Any) = value is T // 컴파일 O
// reified 키워드는 이 타입 파라미터가 실행 시점에 지워지지 않음을 표시
```

리스트 9.9의 filterIsInstance 참고!



### 9.2.4 실체화한 타입 파라미터의 제약

* 타입 파라미터 클래스의 인스턴스 생성하기
* 타입 파라미터 클래스의 동반 객체 메소드 호출하기
* 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
* 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기



## 9.3 변성: 제네릭과 하위 타입

변성 : 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념 (List<String>, List<Any>)



### 9.3.1 변성이 있는 이유: 인자를 함수에 넘기기

List<Any> 타입의 파라미터를 받는 함수에 List<String>을 넘기면 안전한가?

* 리스트의 원소를 추가하거나 변경한다면 타입 불일치가 생길 수 있어서 X

* 원소 추가나 변경이 없는 경우에도 가능



### 9.3.2 클래스, 타입, 하위 타입

타입과 클래스의 차이

List는 타입이 아니다 (but 클래스) 타입인자를 치환한 List<Int>, List<String?>, 등은 모두 타입



__하위 타입__ : 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없는 관계
				 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입

__상위 타입__ : 하위 타입의 반대. A 타입이 B 타입의 하위 = B 타입이 A 타입의 상위

컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행



__무공변__ : 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않는 제네릭 타입



### 9.3.3 공변성: 하위 타입 관계를 유지

* 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 함

* 공변적으로 만들면 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 반환값으로 사용할 수 있음
* 공변적 파라미터는 항상 out 위치에만 있어야함 (생산)

### 9.3.4 반공변성: 뒤집힌 하위 타입 관계

* 타입 B가 타입 A의 하위 타입이면서, Consumer<A>가 Consumer<B>의 하위 타입 관계가 성립할 때
* in 위치에서 사용



### 9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지점

__선언 지점 변성__ : 클래스를 선언하면서 변성을 지정 (그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼침)

__사용 지점 변성__ : 타입 파라미터가 있는 타입을 사용할때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시



### 9.3.6 스타 프로젝션: 타입 인자 대신 * 사용

* <*> 와 <Any?>는 같지 않다!
* 제네릭 클래스의 타입 인자가 어떤 타입인지 정보가 없거나 타입 인자가 어떤 타입인지 중요하지 않을 때
